package de.mineking.database.vendors.postgres

import de.mineking.database.*
import de.mineking.database.vendors.postgres.PostgresConnection.Companion.logger
import org.jdbi.v3.core.kotlin.useHandleUnchecked
import org.jdbi.v3.core.statement.UnableToExecuteStatementException
import org.postgresql.util.PSQLState
import java.sql.SQLException
import kotlin.reflect.KClass

class PostgresTable<T: Any>(
	tableType: KClass<*>,
	structure: TableStructure<T>,
	instance: () -> T
) : TableImplementation<T>(tableType, structure, instance) {
	override fun createTable() {
		val columns = structure.columns

		fun formatColumn(column: ColumnData<*, *>): String {
			val type = column.mapper.getType(column, column.table, column.type)
			return """
				"${ column.name }" ${ type.sqlName }
				${ if (type.nullable) "" else "not null" }
				${ if (column.property.hasDatabaseAnnotation<AutoIncrement>()) " generated by default as identity" else "" }
				${ 
					if (column.property.hasDatabaseAnnotation<AutoGenerate>()) " default ${ column.property.getDatabaseAnnotation<AutoGenerate>()?.generator?.takeIf { it.isNotBlank() } ?: structure.manager.autoGenerate(column) } }" 
					else "" 
				}
			"""
		}

		val keys = structure.getKeys()
		val unique = columns.filter { it.property.hasDatabaseAnnotation<Unique>() }.groupBy { it.property.getDatabaseAnnotation<Unique>()!!.name }

		structure.manager.driver.useHandleUnchecked { it.createUpdate("""
			create table if not exists ${ structure.name } (
				${ columns.joinToString { formatColumn(it) } }
				${ if (keys.isNotEmpty()) ", primary key (${ keys.joinToString { "\"${it.name}\"" } })" else "" }
				${ if (unique.isNotEmpty()) ", ${ unique.map { "unique (${ it.value.joinToString { "\"${ it.name }\"" } })" }.joinToString() }" else "" }
			)
		""".trim().replace("\\s+".toRegex(), " ")).execute() }

		structure.manager.driver.useHandleUnchecked { it.createQuery("select * from ${ structure.name } limit 1").execute { supplier, _ ->
			val meta = supplier.get().resultSet.metaData
			if (columns.size != meta.columnCount) logger.warn("[${structure.name}] Number of columns in code and database do not match (Code: ${ columns.size }, Database: ${ meta.columnCount })")
			else for (i in 1 .. meta.columnCount) {
				val name = meta.getColumnName(i)
				val column = structure.getFromDatabase(name)

				if (column == null) logger.warn("[${structure.name}] Column $name from database not found in code")
			}
		} }
	}

	override fun <T> createResult(function: () -> T): Result<T> {
		return try {
			Result(function(), null, uniqueViolation = false, notNullViolation = false)
		} catch (e: UnableToExecuteStatementException) {
			val sqlException = e.cause as SQLException
			val result = Result<T>(
				null, sqlException,
				sqlException.sqlState == PSQLState.UNIQUE_VIOLATION.state,
				sqlException.sqlState == PSQLState.NOT_NULL_VIOLATION.state
			)

			if (!result.uniqueViolation && !result.notNullViolation) throw e
			result
		}
	}
}